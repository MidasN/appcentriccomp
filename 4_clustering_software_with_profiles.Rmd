```{r}


m3 %>% class()
m3 %>% View()

profiles = m3  %>% dplyr::select(RecordNo, profile, posterior_prob)

```



```{r}


jobtitleanddescription <- df_clean[, c("RecordNo", "Q18_1_open", "Q18a", "Occupation_DISCO", "Occupation")]
merged <- merge(x = software_cleaned, y = jobtitleanddescription, by= "RecordNo")
merged %<>% select(-a, -Q18_1_open, -Q18a, -Occupation_DISCO)


merged = merged[!is.na(merged$a2),] # removing NA's from the a column
merged %<>% dplyr::rename(a = a2)

merged %>% View()



## nrow(merged)
merged$RecordNo %<>% as.numeric()
profiles$RecordNo %<>% as.numeric()

## Checking
anti_join(merged, profiles, by = "RecordNo")


merged_with_profiles = inner_join(merged, profiles, by = "RecordNo")



## mered_with_prfiles = merged %>%
##   group_by(q, RecordNo) %>%
##   mutate(ind = row_number()) %>% 
##   spread(q, a, fill = "Nothing") %>%
##   select(-ind) %>% 
##   View()


pre_dist =
  merged %>% 
  gather(key, val, Occupation) %>%
  group_by(a, val) %>% 
  tally() %>% 
  spread(val, n, fill = 0)

nrow(pre_dist)


  ## merged_with_profiles %>% dplyr::select(profile, a, posterior_prob) %>% 
  ## gather(key, val, profile) %>% # dplyr::mutate(val_weighted = posterior_prob*as.numeric(val)) %>% 
  ## group_by(a, val) %>% 
  ## tally() %>% View()



profiling_dist = merged_with_profiles %>% dplyr::select(profile, a, posterior_prob) %>% 
  gather(key, val, profile) %>% # dplyr::mutate(val_weighted = posterior_prob*as.numeric(val)) %>% 
  group_by(a, val) %>% 
  tally(wt = posterior_prob) %>% # View()
  spread(val, n, fill = 0)  # %>% View()


nrow(profiling_dist)




# anti_join(pre_dist, profiling_dist, by = "a")

occupation_profiling_dist = inner_join(pre_dist, profiling_dist, by = "a")





## FIXME: loosing the information about the device used
## merged %<>% dplyr::select(-RecordNo, -q)
# merged %>% tidyr::spread(key = a, value = Occupation) %>% View

## summary(merged$Occupation %>% as.factor())
## summary(merged$a %>% as.factor())

## TODO: mds on 100/200 pieces of software OR everything with frequency above 4/5

## pre_dist =
##   merged %>% 
##   gather(key, val, Occupation) %>% 
##   group_by(a, val) %>% 
##   tally() %>% 
##   spread(val, n, fill = 0)



## merged %>% View
## pre_dist %>% View

occupation_profiling_dist %>% head()

```


TODO: should I rescale/center data before MDS? kmeans? tsne (probably not)?

```{r}


d = dist(occupation_profiling_dist[,-1]) # euclidean distances between the rows
d = dist(occupation_profiling_dist[,-1], method = 'maximum' ) # euclidean distances between the rows
d = dist(occupation_profiling_dist[,-1], method = 'manhattan' ) # euclidean distances between the rows
d = dist(occupation_profiling_dist[,-1], method = 'minkowski' ) # euclidean distances between the rows

d = dist(occupation_profiling_dist[,-1], method = 'canberra' ) # euclidean distances between the rows
## d = dist(pre_dist[,-1], method = 'binary' ) # euclidean distances between the rows

fit = cmdscale(d, k=2) # k is the number of dim


fit_tb = fit %>% as_tibble()
colnames(fit_tb) <- c("Dim.1", "Dim.2")


## library(MASS)
## fit <- isoMDS(d, k=2) # k is the number of dim
## fit # view results

# plot solution 
x <- fit$points[,1]
y <- fit$points[,2]


## occupation_profiling_dist %>% View()


## based on number of appearences defined in software_aggregated df
labels_to_select = occupation_profiling_dist$a[occupation_profiling_dist$a %in% software_aggregated$a2[1:115]]


# Plot MDS
ggscatter(fit_tb, x = "Dim.1", y = "Dim.2", 
          label = occupation_profiling_dist$a,
          label.select = labels_to_select,
          size = 1,
          repel = TRUE)




```

```{r}


# K-means clustering
clust = kmeans(fit_tb, 6)$cluster %>% as.factor()
fit_tb = fit_tb %>% mutate(groups = clust)
# Plot and color by groups
ggscatter(fit_tb,
          x = "Dim.1", y = "Dim.2", 
          label = occupation_profiling_dist$a,
          label.select = labels_to_select,
          color = "groups",
          star.plot=TRUE,
          palette = "jco",
          size = 1, 
          ellipse = TRUE,
          ellipse.type = "convex",
          repel = TRUE)
# +geom_hline(yintercept=0, color = "red", size = 2)




```


t-sne

```{r}

library(caret)  
library(Rtsne)

d = dist(pre_dist[,-1], method = 'canberra' ) # euclidean distances between the rows

tsne_model_1 = Rtsne(as.matrix(occupation_profiling_dist[,-1]),
                     check_duplicates=FALSE,
                     pca=TRUE,
                     perplexity=30, theta=0.5,
                     dims=2)


d_tsne_1 = as.data.frame(tsne_model_1$Y)  



```


```{r}

## plotting the results without clustering
ggplot(d_tsne_1, aes(x=V1, y=V2)) +  
  geom_point(size=0.25) +
  guides(colour=guide_legend(override.aes=list(size=6))) +
  xlab("") + ylab("") +
  ggtitle("t-SNE") +
  theme_light(base_size=20) +
  theme(axis.text.x=element_blank(),
        axis.text.y=element_blank()) +
  scale_colour_brewer(palette = "Set2")





```



```{r}

## keeping original data
d_tsne_1_original=d_tsne_1

## Creating k-means clustering model, and assigning the result to the data used to create the tsne
fit_cluster_kmeans=kmeans(scale(d_tsne_1), 6)  
d_tsne_1_original$cl_kmeans = factor(fit_cluster_kmeans$cluster)

## Creating hierarchical cluster model, and assigning the result to the data used to create the tsne
fit_cluster_hierarchical=hclust(dist(scale(d_tsne_1)))

## setting 3 clusters as output
d_tsne_1_original$cl_hierarchical = factor(cutree(fit_cluster_hierarchical, k=3))

```

TODO: Function to got predefined number of software labels for each cluster


```{r}

# labels_to_select =

d_tsne_1_original$a = occupation_profiling_dist$a
d_tsne_1_origin$a


software_aggregation

d_tsne_1_original %>% group_by(cl_kmeans) %>% mutate(n = n()) %>% mutate(n_w = n/sum(n)) %>% View()
d_tsne_1_original %>% sample_n(50, weight=pop.weight, replace = TRUE) %>%

occupation_profiling_dist$a[occupation_profiling_dist$a %in% software_aggregated$a2[1:115]]




```


```{r}



d_tsne_1_original$cl_kmeans %<>% as.factor()

# fit_tb = fit_tb %>% mutate(groups = clust)
# Plot and color by groups

ggscatter(d_tsne_1_original,
          x = "V1", y = "V2", 
          label = occupation_profiling_dist$a,
          label.select = labels_to_select,
#          color = "cl_kmeans",
          color = "cl_hierarchical",
          star.plot=TRUE,
          palette = "jco",
          size = 1, 
          ellipse = TRUE,
          ellipse.type = "convex",
          repel = TRUE)
# +geom_hline(yintercept=0, color = "red", size = 2)





plot_cluster=function(data, var_cluster, palette)  
{
  ggplot(data, aes_string(x="V1", y="V2", color=var_cluster)) +
  geom_point(size=0.25) +
  guides(colour=guide_legend(override.aes=list(size=6))) +
  xlab("") + ylab("") +
  ggtitle("") +
  theme_light(base_size=20) +
  theme(axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        legend.direction = "horizontal", 
        legend.position = "bottom",
        legend.box = "horizontal") + 
    scale_colour_brewer(palette = palette) 
}


plot_k=plot_cluster(d_tsne_1_original, "cl_kmeans", "Accent")  
plot_h=plot_cluster(d_tsne_1_original, "cl_hierarchical", "Set1")

## and finally: putting the plots side by side with gridExtra lib...
library(gridExtra)  
grid.arrange(plot_k, plot_h,  ncol=2)  



```
